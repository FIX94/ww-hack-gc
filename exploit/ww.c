// Copyright 2008-2009  Segher Boessenkool  <segher@kernel.crashing.org>
// GameCube Port Copyright 2016 FIX94
// This code is licensed to you under the terms of the GNU GPL, version 2;
// see file LICENSE or http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt

//#include "loader.h"

#define TO_ARAM 0
#define TO_MRAM 1

typedef unsigned int u32;
typedef unsigned short u16;
typedef unsigned char u8;
typedef volatile unsigned int vu32;
typedef volatile unsigned short vu16;

typedef struct _cInfo
{
    int chan;
    int fnum;
    int offset;
    int length;
    u16 block;
} cInfo;

int card_open_E0(int chan, const char *path, cInfo *inf);
int card_open_J0(int chan, const char *path, cInfo *inf);
int card_open_P0(int chan, const char *path, cInfo *inf);

int card_read_E0(cInfo *inf, void* addr, int length, int offset);
int card_read_J0(cInfo *inf, void* addr, int length, int offset);
int card_read_P0(cInfo *inf, void* addr, int length, int offset);

int card_close_E0(cInfo *inf);
int card_close_J0(cInfo *inf);
int card_close_P0(cInfo *inf);

void audio_stop_E0(void);
void audio_stop_J0(void);
void audio_stop_P0(void);

void gx_flush_E0(void);
void gx_flush_J0(void);
void gx_flush_P0(void);

void gx_abortframe_E0(void);
void gx_abortframe_J0(void);
void gx_abortframe_P0(void);

void gx_drawdone_E0(void);
void gx_drawdone_J0(void);
void gx_drawdone_P0(void);

void sync_cache(void *p, unsigned int n)
{
	unsigned int start, end;

	start = (unsigned int)p & ~31;
	end = ((unsigned int)p + n + 31) & ~31;
	n = (end - start) >> 5;

	while (n--) {
		asm("dcbst 0,%0 ; icbi 0,%0" : : "b"(p));
		p += 32;
	}
	asm("sync ; isync");
}

void *_memcpy(void *ptr, const void *src, int size)
{
	char* ptr2 = ptr;
	const char* src2 = src;
	while(size--) *ptr2++ = *src2++;
	return ptr;
}

void ar_dma(unsigned int type, unsigned int mram, unsigned int aram, unsigned int len)
{
	*(volatile unsigned short*)0xCC005020 = (mram>>16);
	*(volatile unsigned short*)0xCC005022 = (mram&0xFFFF);
	*(volatile unsigned short*)0xCC005024 = (aram>>16);
	*(volatile unsigned short*)0xCC005026 = (aram&0xFFFF);
	*(volatile unsigned short*)0xCC005028 = (type<<15)|(len>>16);
	*(volatile unsigned short*)0xCC00502A = (len&0xFFFF);
	while(*(volatile unsigned short*)0xCC00500A & 0x200) ;
}

void __attribute__ ((noreturn)) _main()
{
	char *gameid = (char *)0x80000000;
	int (*card_open)(int chan, const char *path, cInfo *inf);
	int (*card_read)(cInfo *inf, void* addr, int length, int offset);
	int (*card_close)(cInfo *inf);
	void (*audio_stop)(void);
	void (*gx_flush)(void);
	void (*gx_abortframe)(void);
	void (*gx_drawdone)(void);

	switch (gameid[3]) {
	case 'E':
		card_open = card_open_E0;
		card_read = card_read_E0;
		card_close = card_close_E0;
		audio_stop = audio_stop_E0;
		gx_flush = gx_flush_E0;
		gx_abortframe = gx_abortframe_E0;
		gx_drawdone = gx_drawdone_E0;
		break;
	case 'P':
		card_open = card_open_P0;
		card_read = card_read_P0;
		card_close = card_close_P0;
		audio_stop = audio_stop_P0;
		gx_flush = gx_flush_P0;
		gx_abortframe = gx_abortframe_P0;
		gx_drawdone = gx_drawdone_P0;
		break;
	case 'J':
		card_open = card_open_J0;
		card_read = card_read_J0;
		card_close = card_close_J0;
		audio_stop = audio_stop_J0;
		gx_flush = gx_flush_J0;
		gx_abortframe = gx_abortframe_J0;
		gx_drawdone = gx_drawdone_J0;
		break;
	default:
		for (;;)
			;
	}
	//prevent BEEPing
	audio_stop();
	//cleanup GX
	gx_drawdone();
	gx_abortframe();
	gx_flush();
	//get our dol loader in memory
	cInfo mInf;
	card_open(0, "gczelda", &mInf);
	card_read(&mInf, (void*)0x80001800, 0x400, 0x1800);
	sync_cache((void*)0x80001800, 0x400);
	card_close(&mInf);
	//game id DOLX00 for boot.dol
	*(volatile u32*)0x80000000 = 0x444F4C58;
	*(volatile u16*)0x80000004 = 0x3030;
	sync_cache((void*)0x80000000, 6);
	//open up boot.dol from memory card
	card_open(0, "boot.dol", &mInf);
	//copy until it returns error
	u32 curOffset = 0;
	while(card_read(&mInf, (void*)0x80001C00, 0x200, curOffset) == 0)
	{
		sync_cache((void*)0x80001C00, 0x200);
		ar_dma(TO_ARAM, 0x1C00, curOffset, 0x200);
		curOffset += 0x200;
	}
	//we are done
	card_close(&mInf);
	//jump to it
	__asm__ volatile(
		"lis 3, 0x8000\n"
		"ori 3, 3, 0x1800\n"
		"mtlr 3\n"
		"blr\n"
	);
	__builtin_unreachable();
}
